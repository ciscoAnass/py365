import socket
import threading
import logging
import paramiko
import os
import json
import datetime
import base64
import uuid
import random
import string
import sys
import hashlib
import queue
import time
import ipaddress

class SSHHoneypot:
    def __init__(self, host='0.0.0.0', port=22):
        self.host = host
        self.port = port
        self.log_file = 'honeypot_log.json'
        self.logs = []
        self.setup_logging()
        self.generate_ssh_keys()

    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s: %(message)s',
            handlers=[
                logging.FileHandler('honeypot.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)

    def generate_ssh_keys(self):
        if not os.path.exists('ssh_host_rsa_key'):
            key = paramiko.RSAKey.generate(2048)
            key.write_private_key_file('ssh_host_rsa_key')
        self.host_key = paramiko.RSAKey(filename='ssh_host_rsa_key')

    def log_connection(self, client_ip, username, password, commands=None):
        log_entry = {
            'timestamp': datetime.datetime.now().isoformat(),
            'client_ip': client_ip,
            'username': username,
            'password': base64.b64encode(password.encode()).decode(),
            'commands': commands or [],
            'session_id': str(uuid.uuid4())
        }
        self.logs.append(log_entry)
        self.save_logs()

    def save_logs(self):
        try:
            with open(self.log_file, 'w') as f:
                json.dump(self.logs, f, indent=2)
        except Exception as e:
            self.logger.error(f"Failed to save logs: {e}")

    def handle_client(self, client_socket, addr):
        transport = None
        try:
            transport = paramiko.Transport(client_socket)
            transport.add_server_key(self.host_key)
            server = CustomSSHServer()
            transport.start_server(server=server)

            channel = transport.accept(1)
            if not channel:
                return

            client_ip = addr[0]
            server.client_ip = client_ip

            channel.send(b"Welcome to Ubuntu 20.04.3 LTS\r\n")
            
            while True:
                try:
                    command = channel.recv(1024).decode('utf-8').strip()
                    if not command:
                        break

                    if command.lower() in ['exit', 'logout', 'quit']:
                        break

                    fake_response = self.generate_fake_response(command)
                    channel.send(fake_response.encode('utf-8') + b'\r\n')
                    
                    server.log_command(command)

                except Exception as e:
                    break

        except Exception as e:
            self.logger.error(f"Client connection error: {e}")
        finally:
            if transport:
                transport.close()

    def generate_fake_response(self, command):
        responses = {
            'uname': 'Linux honeypot 5.4.0-42-generic #46-Ubuntu SMP Fri Feb 28 16:39:43 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux',
            'whoami': 'ubuntu',
            'pwd': '/home/ubuntu',
            'ls': 'file1.txt file2.txt script.sh',
            'cat': 'This is a sample file content generated by the honeypot.',
            'id': 'uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)',
            'ifconfig': '...',
            'netstat': '...'
        }
        return responses.get(command, f"bash: {command}: command not found")

    def start(self):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind((self.host, self.port))
        server_socket.listen(100)

        self.logger.info(f"SSH Honeypot listening on {self.host}:{self.port}")

        while True:
            try:
                client_socket, addr = server_socket.accept()
                client_thread = threading.Thread(target=self.handle_client, args=(client_socket, addr))
                client_thread.start()
            except Exception as e:
                self.logger.error(f"Server error: {e}")

class CustomSSHServer(paramiko.ServerInterface):
    def __init__(self):
        self.client_ip = None
        self.username = None
        self.commands = []

    def check_auth_password(self, username, password):
        honeypot = SSHHoneypot()
        honeypot.log_connection(self.client_ip, username, password)
        self.username = username
        return paramiko.AUTH_SUCCESSFUL

    def check_channel_request(self, kind, chanid):
        return paramiko.OPEN_SUCCEEDED

    def log_command(self, command):
        self.commands.append(command)

def main():
    honeypot = SSHHoneypot()
    honeypot.start()

if __name__ == '__main__':
    main()